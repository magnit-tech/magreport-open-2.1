// Нотация "Язык формул Maglang"
// https://coderepo.corp.tander.ru/BI/magreport2.1/-/tree/main/magreport-frontend/src/main/Report/Pivot/maglangFormulaEditor

// Описание языка
export const DFD_languageConstructs = [
	{
		name: 'выражения',
		descr: ` -- часть формулы, которая может быть вычисленна как
		числовое, логическое, строковое значение или значение момента
		времени (даты или даты со временем); вся формула также представляет
		собой некоторое выражение;`,
	},
	{
		name: 'константы',
		descr: ' -- числовые, символьные и логические литералы; числовые литералы записываются в обычной форме записи с целой частью, дробной частью и экспонентой, нулевую целую часть можно опускать (3, -2.57, .18, 2E3, -3.5e4); целочисленные литералы представляются в системе через 64-битный целочисленный знаковый тип, вещественные -- через 64-битный тип чисел с плавающей запятой; символьные литералы записываются в виде строк, заключённых в двойные кавычки ("понедельник"); логически литералы записываются при помощи ключевых слов <strong>True</strong> и <strong>False</strong>; литералов для задания моментов времени (даты и даты со временем) не предусмотрено -- для их задания необходимо использовать соответствующие функции;' ,
	},
	{
		name: 'арифметические выражения',
		descr: ' -- для числовых выражений доступно вычисление арифметических операций: сложение (+), вычитание (-), умножение (*), вещественное деление (/), целочисленное деление (то есть, целая часть от деления: //), вычисление остатка от деления (%) и унарный минус (знак "-" перед выражением); при вычислении арифметических выражений действуют обычные правила приоритета операций, для управления порядком вычислений можно использовать круглые скобки;',
	},
	{
		name: 'исходные поля отчёта',
		descr: ' -- при вычислении выражений можно использовать значения полей, исходно присутствующих в отчёте, для этого, названия этих полей заключаются в одинарные квадратные скобки (например, [Продажи], [Потери], [Остаток]);',
	},
	{
		name: 'производные поля',
		descr: ' -- при вычислении выражений можно использовать значения других производных полей (при этом главное, чтобы не было рекурсивных зависимостей в вычислениях), для этого, названия этих полей заключаются в двойные квадратные скобки (например, [[Маржинальность]], [[Относительные потери]]); имена производных полей, создаваемых конкретным пользователем обязаны быть уникальными, однако глобальная уникальность не требуется, также уникальными обязаны быть имена общедоступных производных полей -- производных полей, созданных разработчиком отчёта и объявленных, как общедоступные; при работе с производными полями пользователю доступны поля из текущей области видимости производных полей, которая включает в себя общедоступные производные поля, производные поля, созданные данным пользователем, и производные поля, присутствующие в данной конфигурации сводной таблицы; если в области видимости производных полей возникает дублирование имен, то более приоритетные поля остаются просто со своим именем, а к имени менее приоритетных через знак ";" (точка с запятой) добавляется логин пользователя, создавшего поле, приоритет полей от большего к меньшему: общедоступные производные поля, производные поля данного пользователя, производные поля других пользователей;',
	},
	{
		name: 'функции',
		descr: ' -- при вычислении выражений могут использоваться функции из библиотеки функций, аргументами функций служат выражения, аргументы записываются через запятую;',
	},
	{
		name: 'условный оператор',
		descr: ' -- условный оператор имеет вид:',
		code: `
if(логическое выражение 1){
	выражение 1
}
elif(логическое выражение 2){
	выражение 2
}
elif(логическое выражение 3){
	выражение 3   
}
...
elif(логическое выражение N){
	выражение N
}
else{
	выражение по умолчанию
}
		`,
		addition: 'при вычислении его возвращаемого значения происходит последовательное вычисление логических выражений вплоть до первого верного, при этом возвращается значение соответствующего выражения; если все условные выражения ложны -- возвращается значение выражения по умолчанию; блоки <strong>elif</strong> в условном операторе могут отсутствовать, блоки <strong>if</strong> и <strong>else</strong> обязательны;'
	},
	{
		name: 'логические выражения',
		descr: ' -- логические выражения формируются при помощи операций сравнения и логических операций;',
	},
		{
		name: 'операции сравнения',
		descr: ' -- стандартные операции меньше (<), больше (>), меньше либо равно (<=), больше либо равно (>=), равно (=), не равно (!= или <>);',
	},
		{
		name: 'логические операции',
		descr: ' -- стандартные логические операции: логическое И (and), логическое ИЛИ (or), логическое ИСКЛЮЧАЮЩЕЕ ИЛИ (xor) и логическое ОТРИЦАНИЕ (not) -- последняя операция требует взятия в скобки инвертируемого логического выражения (например, "not ([Продажи] < [Потери] and [Остаток] > 0)").',
	},
]

// Примеры
export const DFD_exampleList = [
	{
		name: 'Номер месяца',
		descr: 'Пусть у нас в отчёте есть поле <strong>[Дата]</strong>, но нет номера месяца в году. Создадим производное поле <strong>[[Месяц из даты]]</strong>:',
		code: 'MONTH_FROM_DATE([Дата])'
	},
	{
		name: 'Название месяца',
		descr: 'Пусть у нас есть производное поле <strong>[[Месяц из даты]]</strong>, которое даёт числовое выражение, но нам нужно иметь название месяца. Создадим производное поле <strong>[[Название месяца]]</strong>:',
		code: `
if([[Месяц из даты]] = 1){
    "Январь"
}
elif([[Месяц из даты]] = 2){
    "Февраль"
}
elif([[Месяц из даты]] = 3){
    "Март"
}
elif([[Месяц из даты]] = 4){
    "Апрель"
}
elif([[Месяц из даты]] = 5){
    "Май"
}
elif([[Месяц из даты]] = 6){
    "Июнь"
}
elif([[Месяц из даты]] = 7){
    "Июль"
}
elif([[Месяц из даты]] = 8){
    "Август"
}
elif([[Месяц из даты]] = 9){
    "Сентябрь"
}
elif([[Месяц из даты]] = 10){
    "Октябрь"
}
elif([[Месяц из даты]] = 11){
    "Ноябрь"
}
else{
    "Декабрь"
}
		`
	},
	{
		name: 'Номер квартала года',
		descr: 'Пусть у нас есть производное поле <strong>[[Месяц из даты]]</strong>, но нет номера квартала года. Создадим производное поле <strong>[[Квартал]]</strong>:',
		code: '([[Месяц из даты]] - 1) // 3 + 1',
		addition: 'Нетрудно понять, что с учётом целочисленного деления данная формула даёт номер квартала года.'
	},
	{
		name: 'Номер года в двузначном формате',
		descr: 'Пусть у нас в отчёте есть поле <strong>[Дата]</strong>, но нет номера года. Нам нужен номер года в двузначном формате. Создадим производное поле:',
		code: 'YEAR_FROM_DATE([Дата]) % 100'
	},
	{
		name: 'Категория по обороту',
		descr: 'Пусть у вас есть подневные продажи товаров на магазинах и вы хотите классифицировать эти данные по объёму продаж в рублях. Вы можете создать производное поле <strong>[[Категория по обороту]]</strong>:',
		code: `
if([Оборот] < 100){
    "Оборот 1: < 100"
}
elif([Оборот] < 300){
    "Оборот 2: 100 - 300"
}
elif([Оборот] < 500){
    "Оборот 3: 300 - 500"
}
elif([Оборот] < 1000){
    "Оборот 4: 500 - 1000"
}
elif([Оборот с учетом скидок, руб] < 10000){
    "Оборот 5: 1000 - 10000"
}
else{
    "Оборот 6: > 10000"
}		
		`,
		addition: 'Обратите внимание на именование введённых категорий: "Оборот 1...", "Оборот 2...", и т.д. - выбрана такая система наименований, которая даёт нужный порядок этих значений при лексикографической сортировке. После создания этого производного поля его можно использовать, например, для вычисления количества товарных позиций в каждой из категорий в данный день на данном магазине или для вычисления суммарного оборота по каждой категории.'
	},
	{
		name: 'Средняя цена',
		descr: 'Пусть у вас есть подневные продажи товаров на магазинах, в том числе данные по оборотам в рублях и штуках, но нет данных по цене, и вы хотите вычислять такой показатель, как средняя цена, усредняя её по различным измерениям. Базовую формулу для производного поля <strong>[[Средняя цена]]</strong> вы можете записать следующим образом:',
		code: '[Оборот, руб] / [Оборот, шт]',
		addition: 'По такой формуле поле будет вычислено для тех строк, для которых [Оборот, шт] не равен 0. При дальнейшей агрегации (например, по метрике "среднее значение") полученное производное поле будет принимать числовое значение для тех множеств, которое не содержать нулевые значения [Оборот, шт]. Для других же оно будет выдавать значение NaN. Если нули в значениях [Оборот, шт] не редкость, то на высоких уровнях агрегации вероятность появления NaN весьма высока. Поэтому к знаменателю формулы следует применить функцию ZERO_TO_NULL, превращающую нулевые значения в значения NULL, и, как следствие -- значение самого производного поля для таких значений тоже в NULL. При агрегации такие значения не учитываются и дают возможность вычислить агрегат по нормально вычисленным значениям производного поля. Итоговая формула:',
		additionalСode: '[Оборот с учетом скидок, руб] / ZERO_TO_NULL([Оборот, шт])'
	}
]